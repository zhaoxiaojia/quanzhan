<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ACS: Dispatcher User Guide</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">ACS
   </div>
  </td>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('group__DISPATCHER__USER__GUIDE.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">Dispatcher User Guide<div class="ingroups"><a class="el" href="group__ACS__CORE__DOCS.html">ACS Core Docs</a> &raquo; <a class="el" href="group__USER__GUIDE.html">Middleware User Guides</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<div class="dynheader">
Collaboration diagram for Dispatcher User Guide:</div>
<div class="dyncontent">
<center><table><tr><td><img src="group__DISPATCHER__USER__GUIDE.png" border="0" alt="" usemap="#group____DISPATCHER____USER____GUIDE"/>
<map name="group____DISPATCHER____USER____GUIDE" id="group____DISPATCHER____USER____GUIDE">
<area shape="rect" id="node2" href="group__USER__GUIDE.html" title="Middleware User Guides" alt="" coords="5,5,171,32"/>
</map>
</td></tr></table></center>
</div>
<p><b>Version Number:</b> 1.0</p>
<ul>
<li><a class="el" href="group__DISPATCHER__USER__GUIDE.html#ace_dispatcher_intro">Introduction</a></li>
<li><a class="el" href="group__DISPATCHER__USER__GUIDE.html#ace_dispatcher_eco">Ecosystem</a></li>
<li><a class="el" href="group__DISPATCHER__USER__GUIDE.html#ace_dispatcher_usage">Usage</a></li>
<li><a class="el" href="group__DISPATCHER__USER__GUIDE.html#ace_dispatcher_modev">Module Development</a></li>
<li><a class="el" href="group__DISPATCHER__USER__GUIDE.html#ace_dispatcher_knobs">Knobs for System Integrator</a></li>
<li><a class="el" href="group__DISPATCHER__USER__GUIDE.html#ace_dispatcher_reqs">Requirements on Modules</a></li>
</ul>
<h1><a class="anchor" id="ace_dispatcher_intro"></a>
Introduction</h1>
<p>Dispatcher is the event-driven system for ACS. It provides a standard interface for modules to implement that allows a single event loop to service multiple modules.</p>
<div class="image">
<img src="https://m.media-amazon.com/images/G/01/mobile-apps/dex/ace-documentation/acs_disp-1._CB1574745399_.png"/>
</div>
<p><b>Problems it solves</b></p>
<p>The dispatcher pattern is ideal for running modules on resource-constrained environments by enabling multiple modules to share the same task. This helps avoid an explosion in thread count as well as associated stack memory. There may still be multiple tasks, for example: modules A, B, C may share Task 1, and modules D, E may share Task 2.</p>
<div class="image">
<img src="https://m.media-amazon.com/images/G/01/mobile-apps/dex/ace-documentation/acs_disp-2._CB1574745435_.png"/>
</div>
<p><b>Who is it for</b></p>
<ol type="1">
<li>If the module is IO bound because it must wait on completion of HW IO (files, inter chip comm) or network IO (http, mqtt), it spends a substantial amount of time being blocked on those IO to complete when it is scheduled on a dedicated thread.</li>
<li>One way of ensuring the CPU remains busy is to have thread parallelism, but this conflicts with being able to run the module on resource-constrained MCUs.</li>
<li>As an alternative, these modules may be written in an asynchronous style so that these IO events do not block the CPU. Such modules are ideal targets to on-board to the dispatcher pattern.</li>
</ol>
<h1><a class="anchor" id="ace_dispatcher_eco"></a>
Ecosystem</h1>
<p>Here is an overview of where dispatcher fits in the ACS ecosystem. Dispatcher sits above the OSAL and provides an event-driven framework for middleware and products to use in their designs. As it stands today the dispatcher APIs are usable in-process and IPC is used to bring requests in from outside the process. They can then be dispatched from the IPC handler thread to the dispatcher thread.</p>
<ol type="1">
<li>Dispatcher is the event-driven framework that allows ACS to run on small MCUs.</li>
<li>IPC allows modules to communicate with other processes on Linux, Android, etc. (Absent on RTOS).</li>
<li>Events: Universal broadcast notification mechanism. Possible source of events a module may handle inside a dispatcher.</li>
</ol>
<div class="image">
<img src="https://m.media-amazon.com/images/G/01/mobile-apps/dex/ace-documentation/acs_disp-3._CB1574745462_.png"/>
</div>
<h1><a class="anchor" id="ace_dispatcher_usage"></a>
Usage</h1>
<p>The Dispatcher core API caters towards two kinds of users. First is the module developer who builds event-driven applications and second is the system integrator that is in charge of balancing system resources while integrating different modules to build a product.</p>
<p><b>APIs for Module Developer</b></p>
<p>The module developer typically is responsible for its architecture, defining various events and appropriate handlers. The module developer also typically uses the dispatcher_post*() APIs to dispatch work from various threads into the dispatcher for the module to handle later. The developer typically is not concerned with the APIs to create and destroy dispatchers as they are treated as system resources already sized for the product's hardware resources. Dispatcher provides a simple API and a more advanced builder API to dispatch work. Refer to the API doxygen for details. The simple API allows the user to post immediately schedule work. If the user desires to modify how work is scheduled, its best to use the advanced API. The advanced API uses a two step process. In step 1, the user constructs the work object using the work builder API. In the second step, the user posts it to the dispatcher. The user may retain the work object as a handle for canceling work later. See examples in the section on implementing user-facing API. The advanced API supports the following features:</p>
<ul>
<li>Delay work for future execution</li>
<li>Configure work for periodic execution</li>
<li>Modify the priority of execution of the work</li>
</ul>
<p><b>APIs for System Integrator</b></p>
<p>The next user is the system integrator, who is responsible for creating one or more dispatchers as well as registering the modules of interest to these dispatchers. They also handle deregistering the module as well as cleaning up resources by destroying dispatchers. The timing of such actions is outside the scope of this guide and is influenced by factors such as product needs for various components to be active at different states, memory resource availability, etc. The call flow of the most used dispatcher apis follows:</p>
<div class="image">
<img src="https://m.media-amazon.com/images/G/01/mobile-apps/dex/ace-documentation/acs_disp-4._CB1574745490_.png"/>
</div>
<h1><a class="anchor" id="ace_dispatcher_modev"></a>
Module Development</h1>
<p><b>Implement event-driven business logic</b></p>
<p>Define Events (private struct) </p><div class="fragment"><div class="line">typedef enum {</div><div class="line">    HELLO_WORLD_EVT = 1,</div><div class="line">    HELLO_WORLD_SLOW_EVT,</div><div class="line">    HELLO_WORLD_DELAYED_EVT,</div><div class="line">    HELLO_WORLD_URGENT_EVT,</div><div class="line">    HELLO_WORLD_EVT_MAX</div><div class="line">} module_hello_world_event_t;</div></div><!-- fragment --><p><b>Implement event handlers</b></p>
<p>The following handlers handle the events defined above.</p>
<div class="fragment"><div class="line">static void handle_regular_event(void) {</div><div class="line">    ACE_LOGI(ACE_LOG_ID_MAIN, &quot;demoDispatcher&quot;, &quot;Hello World&quot;);</div><div class="line">}</div><div class="line"></div><div class="line">static void handle_slow_event(void) {</div><div class="line">    aceThread_delay(5000);</div><div class="line">    ACE_LOGI(ACE_LOG_ID_MAIN, &quot;demoDispatcher&quot;, &quot;Hello World Slow&quot;);</div><div class="line">}</div><div class="line"></div><div class="line">static void handle_delayed_event(void) {</div><div class="line">    private_state.timer_active = 0;</div><div class="line">    ACE_LOGI(ACE_LOG_ID_MAIN, &quot;demoDispatcher&quot;, &quot;Hello World Delayed&quot;);</div><div class="line">}</div><div class="line"></div><div class="line">static void handle_urgent_event(void) {</div><div class="line">    ACE_LOGI(ACE_LOG_ID_MAIN, &quot;demoDispatcher&quot;, &quot;Hello World Urgent&quot;);</div><div class="line">}</div></div><!-- fragment --><p><b>Implement user facing module API</b></p>
<p>In your implementation call dispatcher api to ship work to your module that may be on another thread.</p>
<ol type="1">
<li>Since work is being dispatched to another thread, the data/ arguments must be allocated in memory that has lifetime beyond the API's return.<ol type="a">
<li>Do not put it on the callers stack.</li>
<li>Use ace_alloc() or mempool() as appropriate.</li>
</ol>
</li>
</ol>
<div class="fragment"><div class="line">ace_status_t ace_sample_module_hello_world_print(void) {</div><div class="line">    ace_status_t retval = validate_request(false);</div><div class="line">    if (retval) {</div><div class="line">        return retval;</div><div class="line">    }</div><div class="line"></div><div class="line">    module_hello_world_msg_t* msg;</div><div class="line">    retval = get_mem_and_init_param(0, &amp;msg);</div><div class="line">    if (retval != ACE_STATUS_OK) {</div><div class="line">        return retval;</div><div class="line">    }</div><div class="line"></div><div class="line">    retval = aceDispatcher_post(&amp;private_state.h, HELLO_WORLD_EVT, (void*)msg,</div><div class="line">                                sizeof(*msg));</div><div class="line">    if (retval != ACE_STATUS_OK) {</div><div class="line">        ACE_LOGE(ACE_LOG_ID_MAIN, &quot;demoDispatcher&quot;,</div><div class="line">                 &quot;Queue PUT failed - %&quot; PRId32, retval);</div><div class="line">        release_mem(&amp;msg);</div><div class="line">    }</div><div class="line">    return retval;</div><div class="line">}</div><div class="line"></div><div class="line">ace_status_t ace_sample_module_hello_world_slow_print(void) {</div><div class="line">    ace_status_t retval = validate_request(false);</div><div class="line">    if (retval) {</div><div class="line">        return retval;</div><div class="line">    }</div><div class="line"></div><div class="line">    module_hello_world_msg_t* msg;</div><div class="line">    retval = get_mem_and_init_param(0, &amp;msg);</div><div class="line">    if (retval != ACE_STATUS_OK) {</div><div class="line">        return retval;</div><div class="line">    }</div><div class="line"></div><div class="line">    // Initialize work item for dispatcher.</div><div class="line">    aceDispatcher_work_t stack_work;</div><div class="line">    retval = aceDispatcher_createWork(&amp;stack_work, HELLO_WORLD_SLOW_EVT, msg,</div><div class="line">                                      sizeof(*msg));</div><div class="line">    if (retval != ACE_STATUS_OK) {</div><div class="line">        release_mem(&amp;msg);</div><div class="line">        return ACE_STATUS_GENERAL_ERROR;</div><div class="line">    }</div><div class="line"></div><div class="line">    // Post work on dispatcher.</div><div class="line">    retval = aceDispatcher_postEx(&amp;private_state.h, &amp;stack_work);</div><div class="line">    if (retval != ACE_STATUS_OK) {</div><div class="line">        release_mem(&amp;msg);</div><div class="line">        return ACE_STATUS_GENERAL_ERROR;</div><div class="line">    }</div><div class="line">    return retval;</div><div class="line">}</div><div class="line"></div><div class="line">ace_status_t ace_sample_module_hello_world_delayed(void) {</div><div class="line">    ace_status_t retval = validate_request(true);</div><div class="line">    if (retval) {</div><div class="line">        return retval;</div><div class="line">    }</div><div class="line"></div><div class="line">    module_hello_world_msg_t* msg;</div><div class="line">    retval = get_mem_and_init_param(1, &amp;msg);</div><div class="line">    if (retval != ACE_STATUS_OK) {</div><div class="line">        return retval;</div><div class="line">    }</div><div class="line"></div><div class="line">    // Initialize work item for dispatcher.</div><div class="line">    retval =</div><div class="line">        aceDispatcher_createWork(&amp;private_state.delayed_work,</div><div class="line">                                 HELLO_WORLD_DELAYED_EVT, msg, sizeof(*msg));</div><div class="line">    if (retval != ACE_STATUS_OK) {</div><div class="line">        release_mem(&amp;msg);</div><div class="line">        return ACE_STATUS_GENERAL_ERROR;</div><div class="line">    }</div><div class="line"></div><div class="line">    // Set time delay attribute for work item.</div><div class="line">    aceDispatcher_setPeriod(&amp;private_state.delayed_work, 5000, 0);</div><div class="line"></div><div class="line">    // Post work on dispatcher.</div><div class="line">    retval =</div><div class="line">        aceDispatcher_postEx(&amp;private_state.h, &amp;private_state.delayed_work);</div><div class="line">    if (retval != ACE_STATUS_OK) {</div><div class="line">        release_mem(&amp;msg);</div><div class="line">        return ACE_STATUS_GENERAL_ERROR;</div><div class="line">    }</div><div class="line">    return retval;</div><div class="line">}</div><div class="line"></div><div class="line">ace_status_t ace_sample_module_hello_world_urgent(void) {</div><div class="line">    ace_status_t retval = validate_request(false);</div><div class="line">    if (retval) {</div><div class="line">        return retval;</div><div class="line">    }</div><div class="line"></div><div class="line">    module_hello_world_msg_t* msg;</div><div class="line">    retval = get_mem_and_init_param(1, &amp;msg);</div><div class="line">    if (retval != ACE_STATUS_OK) {</div><div class="line">        return retval;</div><div class="line">    }</div><div class="line"></div><div class="line">    // Initialize work item for dispatcher.</div><div class="line">    retval = aceDispatcher_createWork(&amp;private_state.delayed_work,</div><div class="line">        HELLO_WORLD_URGENT_EVT, msg, sizeof(*msg));</div><div class="line">    if (retval != ACE_STATUS_OK) {</div><div class="line">        release_mem(&amp;msg);</div><div class="line">        return ACE_STATUS_GENERAL_ERROR;</div><div class="line">    }</div><div class="line"></div><div class="line">    // Set priority attribute for work item.</div><div class="line">    aceDispatcher_setPriority(&amp;private_state.delayed_work,</div><div class="line">        ACE_DISPATCHER_PRIORITY_URGENT);</div><div class="line"></div><div class="line">    // Post work on dispatcher.</div><div class="line">    retval =</div><div class="line">        aceDispatcher_postEx(&amp;private_state.h, &amp;private_state.delayed_work);</div><div class="line">    if (retval != ACE_STATUS_OK) {</div><div class="line">        release_mem(&amp;msg);</div><div class="line">        return ACE_STATUS_GENERAL_ERROR;</div><div class="line">    }</div><div class="line">    return retval;</div><div class="line">}</div></div><!-- fragment --><p><b>Implement the top level event demuxer</b></p>
<p>A module must implement the following lifecycle callbacks:</p>
<ol type="1">
<li><a class="el" href="structaceDispatcher__module__s.html#a043b827d92a0e694e8e7259bc8fa737d">aceDispatcher_module_t::on_reg</a></li>
<li><a class="el" href="structaceDispatcher__module__s.html#a2385ccdc017ce2658c200dc26347cda5">aceDispatcher_module_t::on_msg</a></li>
<li><a class="el" href="structaceDispatcher__module__s.html#a65da42ad7f779a1e2362c0b5b83547d7">aceDispatcher_module_t::on_dereg</a> (optional but strongly encouraged): Not implementing this may lead to the module not being able to be stopped and then started again.</li>
</ol>
<div class="fragment"><div class="line">static ace_status_t module_hello_world_on_reg_cb(</div><div class="line">    aceDispatcher_dispatchHandle_t* h, void* ctx) {</div><div class="line">    (void)ctx;</div><div class="line">    memset(&amp;private_state, 0, sizeof(private_state));</div><div class="line">    private_state.mph = aceMP_init(32, 4);</div><div class="line">    private_state.timer_active = 0;</div><div class="line">    private_state.h = *h;</div><div class="line">    private_state.is_init = true;</div><div class="line">    ACE_LOGI(ACE_LOG_ID_MAIN, &quot;demoDispatcher&quot;, &quot;DEBUG hello on_reg call&quot;);</div><div class="line">    return ACE_STATUS_OK;</div><div class="line">}</div><div class="line"></div><div class="line">static ace_status_t module_hello_world_on_dereg_cb(void* ctx) {</div><div class="line">    aceMP_destroy(private_state.mph);</div><div class="line">    memset(&amp;private_state, 0, sizeof(private_state));</div><div class="line">    return ACE_STATUS_OK;</div><div class="line">}</div><div class="line"></div><div class="line">static ace_status_t module_hello_world_process_msg(int event, void* msg,</div><div class="line">                                                   size_t len, void* ctx) {</div><div class="line">    (void)ctx;</div><div class="line">    (void)len;</div><div class="line"></div><div class="line">    if (msg == NULL) {</div><div class="line">        ACE_LOGE(ACE_LOG_ID_MAIN, &quot;demoDispatcher&quot;,</div><div class="line">                 &quot;Sample module: Drop request. null msg&quot;);</div><div class="line">        return ACE_STATUS_BAD_PARAM;</div><div class="line">    }</div><div class="line">    ACE_LOGD(ACE_LOG_ID_MAIN, &quot;demoDispatcher&quot;, &quot;Sample module0: process_msg&quot;);</div><div class="line">    module_hello_world_msg_t* message = (module_hello_world_msg_t*)msg;</div><div class="line"></div><div class="line">    if (private_state.is_init != true) {</div><div class="line">        ACE_LOGW(ACE_LOG_ID_MAIN, &quot;demoDispatcher&quot;,</div><div class="line">                 &quot;Sample module: Drop request. not init&quot;);</div><div class="line">        return ACE_STATUS_UNINITIALIZED;</div><div class="line">    }</div><div class="line"></div><div class="line">    module_hello_world_event_t event_id = event;</div><div class="line">    switch (event_id) {</div><div class="line">        case HELLO_WORLD_EVT:</div><div class="line">            handle_regular_event();</div><div class="line">            break;</div><div class="line">        case HELLO_WORLD_SLOW_EVT:</div><div class="line">            handle_slow_event();</div><div class="line">            break;</div><div class="line">        case HELLO_WORLD_DELAYED_EVT:</div><div class="line">            handle_delayed_event();</div><div class="line">            break;</div><div class="line">        case HELLO_WORLD_URGENT_EVT:</div><div class="line">            handle_urgent_event();</div><div class="line">            break;</div><div class="line">        default:</div><div class="line">            ACE_LOGW(ACE_LOG_ID_MAIN, &quot;demoDispatcher&quot;,</div><div class="line">                     &quot;Sample module: Invalid Event ID&quot;);</div><div class="line">            return ACE_STATUS_GENERAL_ERROR;</div><div class="line">    }</div><div class="line">    release_mem(&amp;message);</div><div class="line">    return ACE_STATUS_OK;</div><div class="line">}</div></div><!-- fragment --><p><b>Implement the LCM interface</b></p>
<ol type="1">
<li>Get module interface: Function is used by the LCM autogen code to retrieve module info and use it to register it to a dispatcher.<ol type="a">
<li>Signature: ace_status_t foo(aceDispatcher_module_t *m)</li>
<li>Supply a name for the module for debugging.</li>
<li>Set callbacks for:<ol type="i">
<li><a class="el" href="structaceDispatcher__module__s.html#a2385ccdc017ce2658c200dc26347cda5">aceDispatcher_module_t::on_msg</a>: Mandatory</li>
<li><a class="el" href="structaceDispatcher__module__s.html#a043b827d92a0e694e8e7259bc8fa737d">aceDispatcher_module_t::on_reg</a>: Mandatory<ol type="A">
<li>This callback is how dispatcher passes in the handle for you to use in later.</li>
<li>The handle is used to ship work for the module to act upon.</li>
<li>This is when you module is ready for interaction with the outside world.</li>
</ol>
</li>
<li><a class="el" href="structaceDispatcher__module__s.html#a65da42ad7f779a1e2362c0b5b83547d7">aceDispatcher_module_t::on_dereg</a>: Optional</li>
</ol>
</li>
<li>Other callbacks may be added in the future.</li>
</ol>
</li>
<li>In addition, LCM autogen is able to call an early init function for the module before dispatchers are created. This should be used only when it is absolutely necessary to initialize state very early on. Typically most initialization can occur inside on_reg callback.</li>
</ol>
<div class="fragment"><div class="line">ace_status_t ace_sample_module_hello_world_init(void) {</div><div class="line">    return ACE_STATUS_OK;</div><div class="line">}</div><div class="line"></div><div class="line">ace_status_t ace_sample_module_hello_world_get_module(</div><div class="line">    aceDispatcher_module_t* m) {</div><div class="line">    m-&gt;on_msg = module_hello_world_process_msg;</div><div class="line">    m-&gt;on_reg = module_hello_world_on_reg_cb;</div><div class="line">    m-&gt;on_dereg = module_hello_world_on_dereg_cb;</div><div class="line">    strncpy(m-&gt;mod_name, &quot;Hello World&quot;, ACE_DISPATCHER_MODULE_NAME_MAXLEN);</div><div class="line">    return ACE_STATUS_OK;</div><div class="line">}</div></div><!-- fragment --><p><b>Configure ACS Lifecycle</b></p>
<p>Snippet from the build section of the module.conf.</p>
<div class="fragment"><div class="line">!&lt;module:ace_dispatcher_demo_hello_world&gt;</div><div class="line">...</div><div class="line">build:</div><div class="line">  BINARY_RESULT: ace_dispatcher_demo_hello_world_app</div><div class="line">  EXPORTED_HEADERS:</div><div class="line">  - include/ace/ace_sample_module_hello_world.h</div><div class="line">  LIFECYCLE: dispatcher</div><div class="line">  MOD_INFO: ace_sample_module_hello_world_get_module</div><div class="line">  INIT_FUNC: ace_sample_module_hello_world_init</div><div class="line">  SHARED_LIBRARIES:</div><div class="line">  - libace_dispatcher</div><div class="line">  - libacelog</div><div class="line">  - libace_osal</div><div class="line">  SRC_FILES:</div><div class="line">  - src/ace_sample_module_hello_world.c</div><div class="line">---</div></div><!-- fragment --><p><b>What you don't have to do (although you can)</b></p>
<ol type="1">
<li>Create a main().</li>
<li>Spawn dispatcher threads.</li>
<li>Perform registration of your module.</li>
</ol>
<p><b>Debugging</b></p>
<ol type="1">
<li>ACE_LOGx with tag aceDispatcher.</li>
<li>Use GDB to break at critical points in dispatcher control flow, or your on_msg.</li>
<li>Make sure you don't allocate on the stack because dispatcher_post() sends work to a different thread.</li>
<li>Recycle memory appropriately.</li>
</ol>
<p><b>Enable conditional logging in dispatcher</b></p>
<p>Additional debug logs can be enabled on a per dispatcher basis that will print details such as which on_msg callback is being executed, event is being posted, number of messages pending in the queue as well as the how long an on_msg callback executed. Any entity holding the module dispatch handle can call <a class="el" href="group__ACE__DISPATCHER__CONFIGURATION__API.html#gaffdc3968f36f98cdf2cc054e450758d0" title="Control log verbosity. ">aceDispatcher_setVerbosity()</a> passing in the handle. On NoART and Linux, where memory isolation is enforced, only the module is able to enable logging by calling aceDispatcher_setVerbosity. On RTOS, logging can be enabled by two additional methods. First, the entity spawning dispatchers and registering modules to it also possesses the handle to each module. It may also call <a class="el" href="group__ACE__DISPATCHER__CONFIGURATION__API.html#gaffdc3968f36f98cdf2cc054e450758d0" title="Control log verbosity. ">aceDispatcher_setVerbosity()</a>. Second, an even simpler method exists on RTOS using CLIs.</p>
<p>Execute the CLI: ace dispatcher debug</p>
<div class="fragment"><div class="line">--&gt;ace fw dispatcher debug</div><div class="line">Dispatchers in the system:</div><div class="line">Dispatcher  Thread      Queue       NumMods</div><div class="line">0x20033058  0x20033060  0x200330cc  1</div><div class="line">0x2003319c  0x200331a4  0x20033210  1</div><div class="line">0x200332e0  0x200332e8  0x20033354  1</div><div class="line">0x200316bc  0x200316c4  0x20031730  1</div><div class="line">Registered dispatcher modules:</div><div class="line">Name              Dispatcher  on_msg      on_reg      on_dereg    ctx</div><div class="line">com.amazon.logmg  0x20033058  0x100ede59  0x100eccbd  0           0</div><div class="line">ACE_MW_POWER      0x2003319c  0x100e4e99  0x100e4e6d  0           0</div><div class="line">ACE_MW_THERMAL    0x200332e0  0x100eaf35  0x100eaf09  0           0</div><div class="line">AceWifiSvc        0x200316bc  0x10085ff1  0           0           0</div><div class="line">cli duration 47ms</div></div><!-- fragment --><p>Next execute the CLI: ace dispatcher set_verbosity &lt;idx&gt; &lt;verbosity flags&gt;=""&gt; Flags can be one of:</p>
<ol type="1">
<li>0 (ACE_DISPATCHER_VERBOSITY_NONE): Turns off all debugging.</li>
<li>1 (ACE_DISPATCHER_VERBOSITY_DEBUG): Prints how full the queue is, the data pointer in the event payload, as well as some additional information on which module's messages are being processed.</li>
<li>2 (ACE_DISPATCHER_VERBOSITY_TIMING): Prints how long an on_msg handler took. <div class="fragment"><div class="line">--&gt;ace fw dispatcher set_verbosity 3 0xFF</div><div class="line">Found dispatcher: 0x200316bc at idx: 3</div><div class="line"></div><div class="line">ace mw wifi scan</div><div class="line">calling aceWifiMgr_startScan...</div><div class="line">cli duration 2ms</div><div class="line"></div><div class="line">--&gt;[1970-01-01 00:03:48.493 D   7 100320cf]ace_wifi:AceWifiSvc: ace wifi svc async call 31</div><div class="line">[1970-01-01 00:03:48.493 D   7 100320cf]aceDispatcher:Queue PUT Done</div><div class="line">[1970-01-01 00:03:48.494 D  14 100320cf]aceDispatcher:Dispatcher 0x10e93c pending msgs: 0 &lt;--------------------------- Number of pending messages in the queue</div><div class="line">[1970-01-01 00:03:48.494 D  14 100320cf]aceDispatcher:Dispatcher 0x10e93c (queue 0x10e9b0): MsgAddr: 0x2001ac04</div><div class="line">[1970-01-01 00:03:48.494 D  14 100320cf]ace_wifi:AceWifiSvc: Scan</div><div class="line">[1970-01-01 00:03:48.494 I  14 10022b75]wifi_hal:Init scan</div><div class="line">[1970-01-01 00:03:48.519 D  14 100320cf]aceDispatcher:Dispatcher 0x10e93c: on_msg duration: W1: 0, W0: 61a0 &lt;--------- on_msg handler execution time</div><div class="line">...</div></div><!-- fragment --></li>
</ol>
<h1><a class="anchor" id="ace_dispatcher_knobs"></a>
Knobs for System Integrator</h1>
<div class="image">
<img src="https://m.media-amazon.com/images/G/01/mobile-apps/dex/ace-documentation/acs_disp-5._CB1574745551_.png"/>
</div>
<p>A policy file will allow the system integrator to tune the system resources and concurrency.</p>
<ol type="1">
<li>Map modules to dispatcher threads.</li>
<li>Define stack size.</li>
<li>Define dispatcher queue size.</li>
<li>Define thread priority.</li>
<li>It may consist of ACS recommended configuration for class of device: small MCU, Linux etc.</li>
<li>Suggested guidelines for combining modules into single dispatcher:<ol type="a">
<li>Sub-components of a single module (like micro services from the cloud world).</li>
<li>Modules that have similar latency sensitivity<ol type="i">
<li>Low Latency: For user facing, set to high priority.</li>
<li>Normal.</li>
<li>Background: Best effort. On an MCU, will not run until higher priority tasks are active.</li>
</ol>
</li>
</ol>
</li>
</ol>
<h1><a class="anchor" id="ace_dispatcher_reqs"></a>
Requirements on Modules</h1>
<p>The dispatcher pattern standardizes asynchronous design for ACS module. It imposes certain restrictions on module code:</p>
<ol type="1">
<li>Modules cannot create their own dispatchers.</li>
<li>Modules are not responsible for cleaning up shared dispatchers using destroy() apis.</li>
<li>While the actual max duration that an event handler can execute is not set, module owners will be required to break up their business logic into small blocks of code that execute in response to events and do not block on IO.</li>
<li>The ACS system/product decide the allocation of module to specific threads. Thus, the module design should always assume there could be other modules also being serviced by the same dispatcher.</li>
<li>Modules will be notified of IO completion using an appropriate event and module &quot;state machine&quot; may resume processing.</li>
</ol>
<p><b>Baby Steps towards non-blocking</b></p>
<p>Dispatcher allows module developers to iteratively improve their design from a traditional blocking design to a non-blocking design.</p>
<ol type="1">
<li>Dispatcher will provide profiling support to identify blocking hot spots to allow module developers to refactor their code.</li>
<li>On Android/Linux platforms, modules will be deployed in their own dispatchers because:<ol type="a">
<li>There is no resource constraint.</li>
<li>Security Policy.</li>
</ol>
</li>
<li>On resource-constrained devices, we will exercise the option to combine modules into fewer dispatchers. Refactoring may involve use of async APIs for IO tasks.</li>
</ol>
<p>Module developers can assume that ACS helper components will facilitate asynchronous IO.</p>
<ol type="1">
<li>Network API: http, mqtt, http2</li>
<li>File system </li>
</ol>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.8.11-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
</div>
</body>
</html>
